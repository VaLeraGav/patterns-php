# Patterns

- [Шаблоны (паттерны) проектирования для людей](https://github.com/design-patterns-for-humans/Russian/blob/master/README.md)

- [32 шаблона проектирования с точки зрения PHP](https://www.youtube.com/watch?v=9X_f2ApKf9I&t=1519s)

- [Теория: Паттерны проектирования (плюсы и минусы)](http://cpp-reference.ru/patterns/)

- [Паттерны на JS: только реализация](https://github.com/mariaparfenyuk/JavaScript-Design-Patterns)

- [Принципы проектирования:Java (Отношения с другими паттернами)](https://github.com/DGarbar/Patterns)

- [Статья откуда взята информация выше](https://radioprog.ru/category/183)

- [Аналитические шаблоны проектирования приложений: Информация](https://intuit.ru/studies/courses/3611/853/info)

## Шаблоны (паттерны) проектирования

#### Почему важно знать паттерны?

- Паттерны проектирования - это обобщенное описание того, что в коде очень часто встречается. Чтобы люди, глядящие в
  этот
  код, могли похожие вещи называть определенным термином.

- Использование повторимой архитектурной конструкции, представляющая собой
  решение проблемы проектирования в рамках некоторого часто возникающего контекста.

Типы Шаблонов Проектирования:

- [Порождающие шаблоны](/creational) (Creational patterns) - сфокусированы на процессе инстанцирования
  объектов или групп связанных объектов. **Сосредоточены на процессе внедрения объектов или групп объектов**
    - [Простая фабрика](#простая-фабрика-simple-factory)
    - [Фабричный метод](#фабричный-метод-factory-method)
    - [Абстрактная фабрика](#абстрактная-фабрика-abstract-factory)
    - [Строитель](#строитель-builder)
    - [Прототип](#прототип-prototype)
    - [Одиночка](#одиночка-singleton)
    - [Статичная фабрика](#статичная-фабрика-static-factory)
    - [Бассейн](#бассейн-object-pool)
    - [Ленивая инициализация]()

- [Структурные шаблоны](/structural) (Structural patterns) - это шаблоны проектирования, которые упрощают
  проектирование,
  определяя простой способ реализации взаимосвязей между объектами. Они помогают ответить на вопрос **«Как создать
  программный компонент?»**
    - [Внедрение Зависимости](#внедрение-зависимости-dependency-injection)
    - [Реестр](#реестр-registry)
    - [Адаптер](#адаптер-adapter--wrapper)
    - [Мост](#мост-bridge)
    - [Декоратор](#декоратор-decorator)
    - [Фасад](#фасад-facade)
    - [Наилегчайший вес (Приспособленец)](#приспособленец-flyweight)
    - [Прокси](#прокси-proxy)
    - [Компоновщик](#компоновщик-composite)
    - [Преобразователь Данных](#преобразователь-данных-data-mapper)

- [Поведенческие шаблоны](/behavioral) (behavioral patterns) - это связано с распределением обязанностей между
  объектами. Что
  отличает их от структурных паттернов, так это то, что они не только определяют структуру, но и обрисовывают в общих
  чертах паттерны для передачи/общения между ними. Или, другими словами, они помогают ответить на вопрос **«Как
  запустить
  поведение в программном компоненте?»**
    - [Цепочка Обязанностей](#цепочка-обязанностей-chain-of-responsibilities)
    - [Команда](#команда-command)
    - [Итератор](#итератор-iterator)
    - [Посредник (Медиатор)](#посредник-mediator)
    - [Наблюдатель](#наблюдатель-observer)
    - [Посетитель](#посетитель-visitor)
    - [Стратегия](#стратегия-strategy)
    - [Состояние](#состояние-state)
    - [Метод шаблона](#шаблонный-метод-template-method)
    - [Объект Null](#объект-null-null-object)
    - [Спецификация](#спецификация-specification)
    - [Локатор Служб](#локатор-служб-service-locator)
    - [Хранилище](#xранилище-repository)
    - [Интерпретатор](#интепретатор-interpreter)
    - [Хранитель](#хранитель-memento)

- [Дополнительно](/additionally)
    - Сущность-Атрибут-Значение (EAV)

## Порождающие шаблоны

Порождающие паттерны проектирования предназначены для создания объектов, позволяя системе оставаться **независимой** как
от самого процесса порождения, так и от типов порождаемых объектов.

## Одиночка (singleton)

[▶ code](/creational/Singleton.php)

Основной смысл использования паттерна "Одиночка" состоит в реализации единственного специального класса, к которому
должны обращаться прочие информационные объекты, причем через единственную точку доступа.

Singleton основана на идее использования глобальной переменной, имеющей следующие важные свойства:

1. Такая переменная доступна всегда. Время жизни глобальной переменной - от запуска программы до ее завершения.
2. Предоставляет глобальный доступ, то есть, такая переменная может быть доступна из любой части программы.

При реализации этого шаблона разумнее создавать именно статические экземпляры абстрактного класса, а не объявлять
требуемые методы статическими. Это будет являться дополнительным преимуществом использования этого шаблона, поскольку
при
применении методов экземпляра можно использовать механизм наследования и создавать подклассы.

[⏏ В начало](#patterns)

## Ленивая инициализация (Lazy Loading)

[▶ code](/creational/Lazy_loading.php)

В компьютерном программировании, ленивая инициализация - это тактика задержки создания объект, вычисление значения или
какой-либо другой дорогостоящий процесс, пока он не понадобится в первый раз. Это своего рода ленивое вычисление,
которое относится конкретно к созданию экземпляров объектов или других ресурсов.

Как вы уже поняли, данный паттерн служит для оптимизации ресурсов.

[⏏ В начало](#patterns)

## Простая фабрика (Simple factory)

[▶ code](/creational/Simple_factory.php)

Простая фабрика просто создает экземпляр для клиента, не предоставляя клиенту какой-либо логики создания.

Когда использовать: Когда создание объекта — это не просто несколько присвоений, а какая-то логика, тогда имеет смысл
создать отдельную фабрику вместо повторения одного и того же кода повсюду.

[⏏ В начало](#patterns)

## Фабричный метод (Factory method)

[▶ code](/creational/Factory_method.php)

В момент создания наследники могут определить, какой класс создавать. Иными словами, данный шаблон делегирует создание
объектов наследникам родительского класса. Это позволяет использовать в коде программы не специфические классы, а
манипулировать абстрактными объектами на более высоком уровне.

Этот паттерн является «настоящим» Шаблоном Проектирования, потому что он следует «Принципу инверсии зависимостей» также
известному как «D» в S.O.L.I.D.

Это означает, что класс FactoryMethod зависит от абстракций, а не от конкретных классов. Это существенный плюс в
сравнении с SimpleFactory или StaticFactory.

Алгоритм реализации этого паттерна выглядит следующим образом:

1. Необходимо унифицировать интерфейсы всех создаваемых объектов.
2. В классе, который производит продукты, создайте пустой "Фабричный метод".
3. В качестве возвращаемого типа укажите общий интерфейс продукта.
4. Переопределите "Фабричный метод" в подклассах, перемещая туда создание соответствующих продуктов.
5. Если создаваемых продуктов слишком много, целесообразно задуматься о введении параметров в "Фабричный метод", которые
   позволят возвращать различные продукты в пределах одного подкласса.

Получаем лаконичный код, в котором явно видна логика (ее не нужно высматривать среди нагромождения методов и параметров)
. Преимуществом этого паттерна является то, что нет необходимости встраивать в код зависящие от приложения классы.

Когда использовать: Полезен, когда есть некоторая общая обработка в классе, но необходимый подкласс динамически
определяется во время выполнения. Иными словами, когда клиент не знает, какой именно подкласс ему может понадобиться.

**Примечание**: Как вы могли уже заметить, «фабричный метод» является как бы основой для «фабрики», «строителя» и
«прототипа». В разработке часто именно так и получается, сперва реализуют фабричный метод, а по мере усложнения кода
выбирают во что именно его преобразовать, в какой из перечисленных паттернов. При использовании «фабричного метода»
каждый объект как бы сам является «фабрикой».

[⏏ В начало](#patterns)

## Статичная фабрика (Static factory)

[▶ code](/creational/Static_factory.php)

Статический фабричный метод — это просто статический метод, который возвращает экземпляр класса.
Она отличается от Простой Фабрики тем, что собственно является статической.

[⏏ В начало](#patterns)

## Абстрактная фабрика (Abstract factory)

[▶ code](/creational/Abstract_factory.php)

Шаблон реализуется созданием абстрактного класса Factory, который представляет собой интерфейс для создания компонентов
системы (например, для оконного интерфейса он может создавать окна и кнопки, семейство взаимосвязанных или
взаимозависимых объектов). Затем пишутся классы, реализующие этот
интерфейс.

Как правило, код становится хуже читаемый, чем «до применения шаблонов». Так же интерфейс абстрактной фабрики фиксирует
набор объектов, которые можно создать. Последующая возможная модернизация, подразумевающая включение новых объектов –
зачастую затруднительная и ресурсоемкая операция.

В ряде случаев удобно прятать Фабрики за Фасадом. Например, в приложении есть десяток своих фабрик, и десяток из
библиотек. Для них можно построить Фасад. Это позволит не линковать библиотеки к каждому модулю, а также легко подменять
одну фабрику на другую.

Когда использовать: Когда есть взаимосвязанные зависимости с не очень простой логикой создания.

Для того чтобы реализация "Абстрактной фабрики" была выполнена, необходимо следовать следующим рекомендациям:

1. Однозначно идентифицируйте правила создания экземпляров.
2. Определите абстрактный класс с интерфейсом, включающим отдельный метод для каждого из классов, экземпляры которых
   должны быть созданы.
3. Для каждого семейства создайте конкретные классы, производные отданного абстрактного класса.
4. Использующий экземпляры объект должен обращаться к "Абстрактной фабрике" для создания требуемых экземпляров.

[⏏ В начало](#patterns)

## Строитель (Builder)

[▶ code](/creational/Builder.php)

Позволяет создавать различные варианты объекта, избегая при этом загрязнения конструктора. Полезно, когда может быть
несколько разновидностей объекта. Или когда есть много шагов, связанных с созданием объекта.

Сказав это, позвольте мне добавить немного о том, что такое анти-шаблон телескопического конструктора. В тот или иной
момент мы все видели конструктор, как показано ниже:

```php
public function __construct($size, $cheese = true, $pepperoni = true, $tomato = false, $lettuce = true)
{
}
```

Кроме того, этот список параметров может продолжать расти, если вы захотите добавить больше параметров в будущем. Это
называется антишаблон телескопического конструктора.

Когда может быть несколько разновидностей объекта и избежать телескопирования конструктора. Ключевое отличие от
фабричного шаблона в том, что; Фабричный шаблон следует использовать, когда создание представляет собой одноэтапный
процесс, а шаблон построителя следует использовать, когда создание представляет собой многоэтапный процесс.

**Примечание**:«`Фабрика`» — это автомат по продаже напитков, в нем уже есть всё готовое (или «осталось разогреть»), а
вы только
говорите что вам нужно (нажимаете кнопку). «`Строитель`» — это завод, который производит эти напитки и содержит в себе
все сложные операции и может собирать сложные объекты из более простых (упаковка, этикетка, вода, ароматизаторы и т.п.)
в зависимости от запроса.

[⏏ В начало](#patterns)

## Прототип (Prototype)

[▶ code](/creational/Prototype.php)

Этот шаблон объявляет интерфейс для клонирования самого себя. Логика приложения, создавая новый объект, обращается к "
Прототипу" с запросом его клонирования.

Отличительными условиями, характеризующими уместность применения шаблона "Прототип", являются:

1. Определение создаваемого объекта динамически, во время выполнения.
2. Нежелательное создание отдельной иерархии классов фабрик для создания объектов-продуктов из параллельной иерархии
   классов (отличие от шаблона "Абстрактная фабрика").
3. Функционал клонирования объекта является более предпочтительным вариантом, нежели его создание и инициализация с
   помощью конструктора.
4. Особенно в ситуациях, когда объект может принимать небольшое ограниченное число возможных состояний.

Нужно заметить, что клонирование не обязательно должно производиться в реализации самого шаблона "Прототип" – это может
быть и какой-то другой объект, к которому сам "Прототип" должен иметь постоянный и полный доступ.

Аналогией этого шаблона является шаблон "`Шаблонный метод`". Разница состоит в том, что "Шаблонный метод"– поведенческий
шаблон проектирования, определяющий основу алгоритма, на которой экземпляры объектов могут переопределять отдельные шаги
общего алгоритма, а "Прототип"–порождающий шаблон, на основе которого объекты создаются.

Когда требуется объект, похожий на существующий объект, или когда создание будет дороже по сравнению с клонированием.

[⏏ В начало](#patterns)

## Бассейн (Object pool)

[▶ code](/creational/Pool.php)

Пулы объектов в основном используются для повышения производительности: в некоторых случаях пулы объектов значительно
повышают производительность. Пулы объектов усложняют жизненный цикл объектов , поскольку объекты, полученные из пула и
возвращенные в него, в настоящее время фактически не создаются и не уничтожаются, и поэтому требуют осторожности при
реализации.

Преимущества

1. Он предлагает значительный прирост производительности.
2. Он управляет подключениями и предоставляет возможность их повторного использования и совместного использования.
3. Шаблон пула объектов используется, когда скорость инициализации экземпляра класса высока.

Когда использовать шаблон проектирования пула объектов

1. Когда у нас есть работа по выделению или освобождению множества объектов
2. Также, когда мы знаем, что у нас есть ограниченное количество объектов, которые одновременно будут находиться в
   памяти.

[⏏ В начало](#patterns)

## Структурные

Используя структурные шаблоны в практической деятельности при разработке программного обеспечения, можно добиться
высоких результатов в создании качественных информационных систем.

Применение структурных шаблонов может гарантировать снижение количества ресурсов на непосредственный процесс разработки
за счет реализации универсальных системных компонентов, вероятность повторного использования которых очень высока.

## Внедрение Зависимости (Dependency Injection)

[▶ code](/structural/Dependency_injection.php)

Для реализации слабосвязанной архитектуры. Чтобы получить более тестируемый, сопровождаемый и расширяемый код.

[⏏ В начало](#patterns)

## Реестр (Registry)

[▶ code](/structural/Registry.php)

это вводит глобальное состояние в вашем приложении, которое не может быть смоделировано для тестирования
и поэтому считается анти-шаблоном! Вместо этого используйте внедрение зависимостей!

Для реализации централизованного хранения объектов, часто используемых во всем приложении, как правило, реализуется с
помощью абстрактного класса только c статическими методами (или с помощью шаблона Singleton). Помните, что это вводит
глобальное состояние, которого следует избегать. Используйте `Dependency Injection` вместо `Registry`.

[⏏ В начало](#patterns)

## Компоновщик (Composite)

[▶ code](/structural/Composite.php)

Применение шаблона "Компоновщик" особенно востребовано, когда в информационной системе реализованы и поддерживаются
древовидные структуры объектов.

Составной шаблон позволяет клиентам обрабатывать отдельные объекты единообразно. Взаимодействие с иерархической группой
объектов также, как и с отдельно взятым экземпляром.

Достоинствами шаблона "Компоновщик" являются:

- легкость добавления новых примитивных или составных объектов;
- простота структуры программы:
- примитивные и составные объекты обрабатываются одинаковым образом.

К недостаткам следует отнести неудобство реализации запрета на добавление в составной объект компонентов определенных
типов.

[⏏ В начало](#patterns)

## Адаптер (Adapter / Wrapper)

[▶ code](/structural/Adapter.php)

Шаблон адаптера позволяет обернуть несовместимый объект в адаптер, чтобы сделать его совместимым с другим классом.

Чаще всего "Адаптер" применяется, если необходимо создать определенный класс, производный от уже существующего.

Привести нестандартный или неудобный интерфейс какого-то класса в интерфейс, совместимый с вашим кодом. Адаптер
позволяет классам работать вместе стандартным образом, что обычно не получается из-за несовместимых интерфейсов,
предоставляя для этого прослойку с интерфейсом, удобным для клиентов, самостоятельно используя оригинальный интерфейс.

[⏏ В начало](#patterns)

## Мост (Bridge)

[▶ code](/structural/Bridge.php)

Шаблон моста предполагает предпочтение композиции наследованию. Детали реализации передаются из иерархии в другой объект
с отдельной иерархией.

Таким образом, если требуется на уровне приложения разделять абстракцию и реализацию так, чтобы и то и другое можно было
изменять независимо, применяют паттерн "Мост"

Существующие подходы к решению подобных задач основаны на принципе наследования, что приводит к тому, что реализация
жестко привязывается к абстракции и последующая независимая модификация очень сложна.

Применение шаблона "Мост" позволяет получить более устойчивые проектные решения для представления элементов абстракции и
реализации, упрощая их возможное последующее изменение.

[⏏ В начало](#patterns)

## Преобразователь Данных (Data Mapper)

[▶ code](/structural/Data_mapper.php)

Преобразователь Данных — это паттерн, который выступает в роли посредника для двунаправленной передачи данных между
постоянным хранилищем данных (часто, реляционной базы данных) и представления данных в памяти (слой домена, то что уже
загружено и используется для логической обработки). Цель паттерна в том, чтобы держать представление данных в памяти и
постоянное хранилище данных независимыми друг от друга и от самого преобразователя данных

Ключевым моментом этого паттерна, в отличие от Активной Записи (Active Records) является то, что модель данных следует
Принципу Единой Обязанности SOLID.

[⏏ В начало](#patterns)

## Декоратор (Decorator)

[▶ code](/structural/Decorator.php)

Шаблон декоратора позволяет динамически изменять поведение объекта во время выполнения, заключая его в объект класса
декоратора.

Возможность динамически добавлять новые обязанности, не прибегая к порождению подклассов, облегчает понимание основных
обязанностей объектов и не запутывает основную бизнес-логику информационных систем.

Можно добавлять и удалять обязанности во время выполнения программы, в то время как при использовании наследования надо
было бы создавать новый класс для каждой дополнительной обязанности.

Данный шаблон позволяет не создавать классов, перегруженных методами. Новые обязанности можно добавлять только по мере
необходимости, не перегружая программное обеспечение лишними классами.

[⏏ В начало](#patterns)

## Фасад (Facade)

[▶ code](/structural/Facade.php)

Фасад предназначен для разделения клиента и подсистемы путем внедрения многих (но иногда только одного) интерфейсов, и,
конечно, уменьшения общей сложности.

Назначение паттерна "Фасад"– упростить работу с существующей системой, определив собственный интерфейс обращения к ней.
При этом определяемый интерфейс должен использовать только определенное множество функций системы или организовать
взаимодействие с ней неким специфическим образом.

Вот почему хороший фасад не содержит созданий экземпляров классов (new) внутри. Если внутри фасада создаются объекты для
реализации каждого метода, это не Фасад, это Строитель или [Абстрактная|Статическая|Простая]
Фабрика [или Фабричный Метод].

[⏏ В начало](#patterns)

## Приспособленец (Flyweight)

[▶ code](/structural/Flyweight.php)

Когда необходимо обеспечить поддержку множества мелких объектов.

Для уменьшения использования памяти Приспособленец разделяет как можно больше памяти между аналогичными объектами. Это
необходимо, когда используется большое количество объектов, состояние которых не сильно отличается. Обычной практикой
является хранение состояния во внешних структурах и передавать их в объект-приспособленец, когда необходимо.

Результатами использования шаблона "Приспособленец" являются:

- уменьшение количества экземпляров объектов, оперируемых в информационной системе;
- оптимизация процесса управления этими объектами.

[⏏ В начало](#patterns)

## Прокси (Proxy)

[▶ code](/structural/Proxy.php)

Создать интерфейс взаимодействия с любым классом, который трудно или невозможно использовать в оригинальном виде. Класс
представляет функциональность другого класса.

[⏏ В начало](#patterns)

## Шаблоны поведенческого проектирования

Поведенческие шаблоны, с точки зрения вклада в архитектурное проектирование, являются связующим звеном между
структурными, порождающими и архитектурными, интеграционными шаблонами.

Оптимальное использование поведенческих шаблонов позволит нивелировать недостатки неудачно спроектированного
программного обеспечения, снизить отдельные, наиболее отрицательные или повысить удачные характеристики программного
продукта.

Именно высокий уровень владения деталями реализации поведенческих паттернов поможет разработчику информационной системы
оперативно устранить самые значимые недостатки отдельных компонентов информационной системы.

## Состояние (State)

[▶ code](/behavioral/State.php)

Состояние - инкапсулирует изменение поведения одних и тех же методов в зависимости от состояния объекта. Этот паттерн
поможет
изящным способом изменить поведение объекта во время выполнения не прибегая к большим монолитным условным операторам.

Использование шаблона "Состояние" локализует зависящее от состояния поведение и делит его на части, соответствующие
состояниям, переходы между состояниями становятся явными, а процесс работы с объектом – более прозрачным и понятным.

[⏏ В начало](#patterns)

## Стратегия (Strategy)

[▶ code](/behavioral/Strategy.php)

В ситуациях, когда определенный класс содержит ряд схожих алгоритмов (способов сделать то или иное действие), как
правило, эти алгоритмы приводят к одному и тому же результату, но могут отличаться по другим параметрам (время
выполнения, потребление системных ресурсов и др.). В подобных ситуациях целесообразно использовать шаблон "Стратегия".

Чтобы разделить стратегии и получить возможность быстрого переключения между ними. Также этот паттерн является хорошей
альтернативой наследованию (вместо расширения абстрактного класса).

К основным преимуществам использования этого шаблона следует отнести следующие:

- Оперативная замена функциональных алгоритмов, выполняющих определенную обязанность.
- Трансформация структуры программного обеспечения в сторону делегирования определенных обязанностей.
- Реализует принцип инкапсуляции.
- Скрывает опасные/лишние данные.

[⏏ В начало](#patterns)

## Объект Null (Null Object)

[▶ code](/behavioral/Object_null.php)

Методы, которые возвращают объект или Null, вместо этого должны вернуть объект NullObject. Это упрощённый формальный
код, устраняющий необходимость проверки if (!is_null($obj)) { $obj->callSomething(); }, заменяя её на обычный вызов
$obj->callSomething();.

[⏏ В начало](#patterns)

## Команда (Command)

[▶ code](/behavioral/Command.php)

Позволяет инкапсулировать действия в объекты. Основная идея этого шаблона — предоставить средства для отделения клиента
от получателя.

Когда необходимо послать объекту запрос, не зная о том, выполнение какой операции запрошено и кто будет получателем,
целесообразно применять шаблон "Команда". Основополагающая идея данного шаблона заключается в использовании единого
интерфейса для описания всех типов операций, которые можно производить с системой. Для добавления в систему поддержки
новой операции достаточно реализовать требуемый интерфейс. Каждая операция представляется самостоятельным объектом,
инкапсулирующим некоторый набор дополнительных свойств.

Известно большое количество задач, где подход к их решению задан с помощью шаблона "Команда":

1. Любое приложение c возможностями отмены или повторения действий (undo/redo) пользователя.
2. Сетевые распределенные системы, использующие запросы в виде объектов в качестве основного примитива инициализации
   каких-либо операций.
3. Системы с поддержкой асинхронных вызовов, инкапсулирующие обратный вызов в виде опроса объекта.

[⏏ В начало](#patterns)

## Итератор (Iterator)

[▶ code](/behavioral/Iterator.php)

Добавить коллекции объектов функционал последовательного доступа к содержащимся в ней экземплярам объектов без
реализации этого функционала в самой коллекции.

Применяется в тех в случаях, когда требуется, чтобы сложный составной объект, например список, предоставлял доступ к
своим элементам (объектам), не раскрывая их внутреннюю структуру, причем перебирать список требуется по-разному в
зависимости от задачи, применяется шаблон "Итератор"

Данный паттерн используется, когда необходим механизм "абстрактного" обхода различных структур данных так, чтобы были
определены алгоритмы, способные взаимодействовать со структурами прозрачно. Если раскрыть тему реализации и возможностей
этого шаблона, то следует сказать о том, что любой составной объект, такой как список, должен предоставлять способ
доступа к его элементам без раскрытия своей внутренней структуры.

[⏏ В начало](#patterns)

## Спецификация (Specification)

[▶ code](/behavioral/Specification.php)

Строит ясное описание бизнес-правил, на соответствие которым могут быть проверены объекты. Композитный класс
спецификация имеет один метод, называемый isSatisfiedBy, который возвращает истину или ложь в зависимости от того,
удовлетворяет ли данный объект спецификации.

[⏏ В начало](#patterns)

## Цепочка Обязанностей (Chain Of Responsibilities)

[▶ code](/behavioral/Chain.php)

В случаях, когда требуется эффективно, компактно, надежно реализовать обработку потока информации с потенциально большим
количеством обработчиков, используется шаблон проектирования "Цепочка обязанностей".

Построить цепочку объектов для обработки вызова в последовательном порядке. Если один объект не может справиться с
вызовом, он делегирует вызов следующему в цепи и так далее.

Шаблон "Цепочка обязанностей" позволяет:

- избежать жесткой зависимости отправителя запроса от его получателя;
- организовать обработку конкретного запроса несколькими объектами, связанными в цепочку;
- вводить конвейер для запроса с множеством возможных обработчиков;
- упростить структурные взаимосвязи между объектами. Отправитель запроса хранит ссылку на начало цепочки, а каждый
- получатель имеет единственную ссылку на своего преемника последующий элемент в цепочке.

[⏏ В начало](#patterns)

## Локатор Служб (Service Locator)

[▶ code](/behavioral/Service_locator.php)

Некоторые считают Локатор Служб **анти-паттерном**. Он нарушает принцип инверсии зависимостей (`Dependency Inversion
principle`) из набора принципов `SOLID`. Локатор Служб скрывает зависимости данного класса вместо их совместного
использования, как в случае шаблона Внедрение Зависимости (`Dependency Injection`). В случае изменения данных
зависимостей
мы рискуем сломать функционал классов, которые их используют, вследствие чего затрудняется поддержка системы.

Для реализации слабосвязанной архитектуры, чтобы получить хорошо тестируемый, сопровождаемый и расширяемый код. Паттерн
`Инъекция зависимостей` (DI) и паттерн `Локатор Служб` — это реализация паттерна Инверсия управления (Inversion of
Control,
IoC).

**Использование** - С Локатором Служб вы можете зарегистрировать сервис для определенного интерфейса. С помощью
интерфейса вы можете получить зарегистрированный сервис и использовать его в классах приложения, не зная его реализацию.
Вы можете настроить и внедрить объект Service Locator на начальном этапе сборки приложения.

[⏏ В начало](#patterns)

## Интерпретатор (Interpreter)

[▶ code](/behavioral/Interpreter.php)

Для некоего языка шаблон описывает его грамматику с помощью терминов «Терминальный символ» и «Нетерминальный символ», а
также описывает интерпретатор предложений, созданных с помощью данного языка.

Как уже было обозначено, данный шаблон проектирования применяется для решения задач часто повторяющихся операций.

Жизненной аналогией этого шаблона является мясорубка, которая способна по определенным правилам преобразовывать
небольшой входной набор кусков различного мяса к определенному виду фарша (разного состава). Такая мясорубка является
достаточно надежным и универсальным инструментом, если на вход ей не подавать что-то совсем плотное и жесткое.

[⏏ В начало](#patterns)

## Посредник (Mediator)

[▶ code](/behavioral/Mediator.php)

Этот паттерн позволяет снизить связность множества компонентов, работающих совместно. Объектам больше нет нужды вызывать
друг друга напрямую. Это хорошая альтернатива Наблюдателю, если у вас есть “центр интеллекта” вроде контроллера (но не в
смысле MVC)

Все компоненты (называемые «Коллеги») объединяются в интерфейс `Mediator` и это хорошо, потому что в рамках ООП, «старый
друг лучше новых двух».

"Посредник" выполняет функцию организации взаимодействия между существующими элементами, которые выполняют свои
обязанности, и новыми компонентами, в которых использование существующих элементов приносит дополнительную ценность
программному продукту, выраженную, как правило, в экономии ресурсов на его реализацию

Применение шаблона "Посредник" позволяет:

- снизить связанность между коллегами;
- централизовать управление системой: этот шаблон заменяет способ взаимодействия " все со всеми " на взаимодействие"
  один со всеми";
- упростить внедрение новой функциональности благодаря слабой связанности кода.

Недостатки же его использования следующие:

- Модули больше не могут взаимодействовать напрямую.
- Использование медиатора приводит к предсказуемому падению производительности–из-за слабой связанности становится
  достаточно трудно определить реакцию системы, отталкиваясь только от событий, происходящих в ней.

[⏏ В начало](#patterns)

## Хранитель (Memento)

[▶ code](/behavioral/Memento.php)

Шаблон предоставляет возможность восстановить объект в его предыдущем состоянии (отменить действие посредством отката к
предыдущему состоянию) или получить доступ к состоянию объекта, не раскрывая его реализацию (т.е. сам объект не обязан
иметь функциональность для возврата текущего состояния).

Шаблон Хранитель реализуется тремя объектами: «Создателем» (originator), «Опекуном» (caretaker) и «Хранитель» (memento).

Основные недостатки и издержки использования этого шаблона проектирования связаны с объемом объекта "Хозяин". Если он
слишком велик, то "Хранитель" должен копировать большой объем информации. Если структура программного продукта
подразумевает частое использование шаблона "Хранитель", то требуются значительные системные ресурсы для поддержки
производительности программного обеспечения.

[⏏ В начало](#patterns)

## Хранилище (Repository)

[▶ code](/behavioral/Repository.php)

Посредник между уровнями области определения (хранилище) и распределения данных. Использует интерфейс, похожий на
коллекции, для доступа к объектам области определения. Репозиторий инкапсулирует набор объектов, сохраняемых в хранилище
данных, и операции выполняемые над ними, обеспечивая более объектно-ориентированное представление реальных данных.
Репозиторий также преследует цель достижения полного разделения и односторонней зависимости между уровнями области
определения и распределения данных.

[⏏ В начало](#patterns)

## Наблюдатель (Observer)

[▶ code](/behavioral/Observer.php)

Для реализации публикации/подписки на поведение объекта, всякий раз, когда объект «`Subject`» меняет свое состояние,
прикрепленные объекты «`Observers`» будут уведомлены. Паттерн используется, чтобы сократить количество связанных
напрямую
объектов и вместо этого использует слабую связь (loose coupling).

В качестве основных достоинств применения шаблона "Наблюдатель" являются:

- Минимальная связанность объекта и наблюдателя.
- Объект знает лишь о том, что у него есть ряд наблюдателей.
- Широковещательность оповещения.
- Объект оповещает не конкретного, а всех подписанных на него наблюдателей.

Недостатками являются:

- Непредвиденные обновления.
- Изменение объекта может вызвать каскад зависимых от него наблюдателей с высокой стоимостью обновления.
- Протокол обновления не содержит никаких сведений о том, что изменилось в субъекте,– работа наблюдателей при этом
  усложняется.

[⏏ В начало](#patterns)

## Шаблонный Метод (Template Method)

[▶ code](/behavioral/Template_method.php)

Когда имеются два разных, но в тоже время очень похожих компонента и требуется внести изменения в оба компонента,
избежав при этом вредоносного дублирования кода, применяется паттерн "Шаблонный метод".

"Шаблонный метод" определяет основной алгоритм и позволяет подклассам изменить некоторые шаги этого алгоритма без
изменения его общей структуры.

Возможно, вы сталкивались с этим уже много раз. Идея состоит в том, чтобы позволить наследникам абстрактного шаблона
переопределить поведение алгоритмов родителя.

Это простой способ изолировать логику в конкретные классы и уменьшить копипаст, поэтому вы повсеместно встретите его в
том или ином виде.

[⏏ В начало](#patterns)

## Посетитель (Visitor)

[▶ code](/behavioral/Visitor.php)

Шаблон «Посетитель» выполняет операции над объектами других классов. Главной целью является сохранение разделения
направленности задач отдельных классов. При этом классы обязаны определить специальный контракт, чтобы позволить
использовать их Посетителям (метод «принять роль» Role::accept в примере).

Контракт, как правило, это абстрактный класс, но вы можете использовать чистый интерфейс. В этом случае, каждый
посетитель должен сам выбирать, какой метод ссылается на посетителя.

Главными преимуществами применения этого паттерна являются следующие:

- Упрощается добавление новых операций к существующим в системе объектам.
- Он объединяет родственные операции в едином классе.

При этом в качестве основного недостатка выделим то, что затруднено добавление новых классов к системным "элементам",
поскольку требуется объявление новой абстрактной операции в классе "Посетитель".

[⏏ В начало](#patterns)

## Дополнительно

## Сущность-Атрибут-Значение (EAV)

[▶ code](/additionally/EAV.php)

Шаблон Сущность-Атрибут-Значение используется для реализации модели EAV на PHP

Модель Сущность-Атрибут-Значение (EAV) - это модель данных, предназначенная для описания сущностей, в которых количество
атрибутов (свойств, параметров), характеризующих их, потенциально огромно, но то количество, которое реально будет
использоваться в конкретной сущности, относительно мало.

[⏏ В начало](#patterns)

























