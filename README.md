# programming-patterns

- [Шаблоны (паттерны) проектирования для людей](https://github.com/design-patterns-for-humans/Russian/blob/master/README.md)

- [32 шаблона проектирования с точки зрения PHP](https://www.youtube.com/watch?v=9X_f2ApKf9I&t=1519s)

- [Теория: Паттерны проектирования (плюсы и минусы)](http://cpp-reference.ru/patterns/)

- [Паттерны на JS](https://github.com/mariaparfenyuk/JavaScript-Design-Patterns)

https://github.com/DGarbar/Patterns/blob/master/src/Structural/Composite/Composite.md

## Шаблоны (паттерны) проектирования

Паттерны проектирования - это обобщенное описание того, что в коде очень часто встречается. Чтобы люди, глядящие в этот
код, могли похожие вещи называть определенным термином.

Есть и другое мнение, появлении паттернов. Использование повторимой архитектурной конструкции, представляющая собой
решение проблемы проектирования в рамках некоторого часто возникающего контекста.

Типы Шаблонов Проектирования:

- [Порождающие шаблоны]() (Creational patterns) - сфокусированы на процессе инстанцирования
  объектов или групп связанных объектов « сосредоточены на процессе внедрения объектов или групп объектов »
    - [Простая фабрика]()
    - [Фабричный метод]()
    - [Абстрактная фабрика]()
    - [Строитель]()
    - [Прототип]()
    - [Одиночка]()

- [Структурные шаблоны]() (Structural patterns) - это шаблоны проектирования, которые упрощают проектирование,
  определяя простой способ реализации взаимосвязей между объектами. Они помогают ответить на вопрос «Как создать
  программный компонент?»
    - [Адаптер]()
    - [Мост]()
    - [Композитный]()
    - [Декоратор]()
    - [Фасад]()
    - [Наилегчайший вес]()
    - [Прокси]()

- [Поведенческие шаблоны]() (behavioral patterns) - это связано с распределением обязанностей между объектами. Что
  отличает их от структурных паттернов, так это то, что они не только определяют структуру, но и обрисовывают в общих
  чертах паттерны для передачи/общения между ними. Или, другими словами, они помогают ответить на вопрос «Как запустить
  поведение в программном компоненте?»
    - [Цепочка ответственности]()
    - [Команда]()
    - [Итератор]()
    - [Медиатор]()
    - [Сувениры]()
    - [Наблюдатель]()
    - [Посетитель]()
    - [Стратегия]()
    - [Состояние]()
    - [Метод шаблона]()

## Порождающие шаблоны

Порождающие паттерны проектирования предназначены для создания объектов, позволяя системе оставаться **независимой** как
от самого процесса порождения, так и от типов порождаемых объектов.

## Одиночка (singleton)

Основной смысл использования паттерна "Одиночка" состоит в реализации единственного специального класса, к которому
должны обращаться прочие информационные объекты, причем через единственную точку доступа.

Singleton основана на идее использования глобальной переменной, имеющей следующие важные свойства:

1. Такая переменная доступна всегда. Время жизни глобальной переменной - от запуска программы до ее завершения.
2. Предоставляет глобальный доступ, то есть, такая переменная может быть доступна из любой части программы.

При реализации этого шаблона разумнее создавать именно статические экземпляры абстрактного класса, а не объявлять
требуемые методы статическими. Это будет являться дополнительным преимуществом использования этого шаблона, поскольку
при
применении методов экземпляра можно использовать механизм наследования и создавать подклассы.

## Простая фабрика (Simple factory)

Простая фабрика просто создает экземпляр для клиента, не предоставляя клиенту какой-либо логики создания.

Когда использовать: Когда создание объекта — это не просто несколько присвоений, а какая-то логика, тогда имеет смысл
создать отдельную фабрику вместо повторения одного и того же кода повсюду.

## Фабричный метод (Factory method)

В момент создания наследники могут определить, какой класс создавать. Иными словами, данный шаблон делегирует создание
объектов наследникам родительского класса. Это позволяет использовать в коде программы не специфические классы, а
манипулировать абстрактными объектами на более высоком уровне.

Алгоритм реализации этого паттерна выглядит следующим образом:

1. Необходимо унифицировать интерфейсы всех создаваемых объектов.
2. В классе, который производит продукты, создайте пустой "Фабричный метод".
3. В качестве возвращаемого типа укажите общий интерфейс продукта.
4. Переопределите "Фабричный метод" в подклассах, перемещая туда создание соответствующих продуктов.
5. Если создаваемых продуктов слишком много, целесообразно задуматься о введении параметров в "Фабричный метод", которые
   позволят возвращать различные продукты в пределах одного подкласса.

Получаем лаконичный код, в котором явно видна логика (ее не нужно высматривать среди нагромождения методов и параметров)
. Преимуществом этого паттерна является то, что нет необходимости встраивать в код зависящие от приложения классы.

Когда использовать: Полезен, когда есть некоторая общая обработка в классе, но необходимый подкласс динамически
определяется во время выполнения. Иными словами, когда клиент не знает, какой именно подкласс ему может понадобиться.

## Статичная фабрика (Static factory)

Статический фабричный метод — это просто статический метод, который возвращает экземпляр класса.
Она отличается от Простой Фабрики тем, что собственно является статической.

## Абстрактная фабрика (Abstract factory)

Шаблон реализуется созданием абстрактного класса Factory, который представляет собой интерфейс для создания компонентов
системы (например, для оконного интерфейса он может создавать окна и кнопки, семейство взаимосвязанных или
взаимозависимых объектов). Затем пишутся классы, реализующие этот
интерфейс.

Как правило, код становится хуже читаемый, чем «до применения шаблонов». Так же интерфейс абстрактной фабрики фиксирует
набор объектов, которые можно создать. Последующая возможная модернизация, подразумевающая включение новых объектов –
зачастую затруднительная и ресурсоемкая операция.

В ряде случаев удобно прятать Фабрики за Фасадом. Например, в приложении есть десяток своих фабрик, и десяток из
библиотек. Для них можно построить Фасад. Это позволит не линковать библиотеки к каждому модулю, а также легко подменять
одну фабрику на другую.

Когда использовать: Когда есть взаимосвязанные зависимости с не очень простой логикой создания.

Для того чтобы реализация "Абстрактной фабрики" была выполнена, необходимо следовать следующим рекомендациям:

1. Однозначно идентифицируйте правила создания экземпляров.
2. Определите абстрактный класс с интерфейсом, включающим отдельный метод для каждого из классов, экземпляры которых
   должны быть созданы.
3. Для каждого семейства создайте конкретные классы, производные отданного абстрактного класса.
4. Использующий экземпляры объект должен обращаться к "Абстрактной фабрике" для создания требуемых экземпляров.

## Строитель (Builde)

Позволяет создавать различные варианты объекта, избегая при этом загрязнения конструктора. Полезно, когда может быть
несколько разновидностей объекта. Или когда есть много шагов, связанных с созданием объекта.

Сказав это, позвольте мне добавить немного о том, что такое анти-шаблон телескопического конструктора. В тот или иной
момент мы все видели конструктор, как показано ниже:

```php
public function __construct($size, $cheese = true, $pepperoni = true, $tomato = false, $lettuce = true)
{
}
```

Кроме того, этот список параметров может продолжать расти, если вы захотите добавить больше параметров в будущем. Это
называется антишаблон телескопического конструктора.

Когда может быть несколько разновидностей объекта и избежать телескопирования конструктора. Ключевое отличие от
фабричного шаблона в том, что; Фабричный шаблон следует использовать, когда создание представляет собой одноэтапный
процесс, а шаблон построителя следует использовать, когда создание представляет собой многоэтапный процесс.

## Прототип (англ. Prototype)

Этот шаблон объявляет интерфейс для клонирования самого себя. Логика приложения, создавая новый объект, обращается к "
Прототипу" с запросом его клонирования.

Отличительными условиями, характеризующими уместность применения шаблона "Прототип", являются:

1. Определение создаваемого объекта динамически, во время выполнения.
2. Нежелательное создание отдельной иерархии классов фабрик для создания объектов-продуктов из параллельной иерархии
   классов (отличие от шаблона "Абстрактная фабрика").
3. Функционал клонирования объекта является более предпочтительным вариантом, нежели его создание и инициализация с
   помощью конструктора.
4. Особенно в ситуациях, когда объект может принимать небольшое ограниченное число возможных состояний.

Нужно заметить, что клонирование не обязательно должно производиться в реализации самого шаблона "Прототип" – это может
быть и какой-то другой объект, к которому сам "Прототип" должен иметь постоянный и полный доступ.

Аналогией этого шаблона является шаблон "Шаблонный метод". Разница состоит в том, что "Шаблонный метод"– поведенческий
шаблон проектирования, определяющий основу алгоритма, на которой экземпляры объектов могут переопределять отдельные шаги
общего алгоритма, а "Прототип"–порождающий шаблон, на основе которого объекты создаются.

Когда требуется объект, похожий на существующий объект, или когда создание будет дороже по сравнению с клонированием.

## Бассейн (Object pool)

Пулы объектов в основном используются для повышения производительности: в некоторых случаях пулы объектов значительно
повышают производительность. Пулы объектов усложняют жизненный цикл объектов , поскольку объекты, полученные из пула и
возвращенные в него, в настоящее время фактически не создаются и не уничтожаются, и поэтому требуют осторожности при
реализации.

Преимущества

1. Он предлагает значительный прирост производительности.
2. Он управляет подключениями и предоставляет возможность их повторного использования и совместного использования.
3. Шаблон пула объектов используется, когда скорость инициализации экземпляра класса высока.

Когда использовать шаблон проектирования пула объектов

1. Когда у нас есть работа по выделению или освобождению множества объектов
2. Также, когда мы знаем, что у нас есть ограниченное количество объектов, которые одновременно будут находиться в
   памяти.

## Структурное

## Внедрение Зависимости (Dependency Injection)

Для реализации слабосвязанной архитектуры. Чтобы получить более тестируемый, сопровождаемый и расширяемый код.

## Реестр (Registry)

это вводит глобальное состояние в вашем приложении, которое не может быть смоделировано для тестирования
и поэтому считается анти-шаблоном! Вместо этого используйте внедрение зависимостей!

## Компоновщик (Composite)

Составной шаблон позволяет клиентам обрабатывать отдельные объекты единообразно.

Взаимодействие с иерархической группой объектов также, как и с отдельно взятым экземпляром.

## Адаптер (Adapter / Wrapper)

Шаблон адаптера позволяет обернуть несовместимый объект в адаптер, чтобы сделать его совместимым с другим классом.

Привести нестандартный или неудобный интерфейс какого-то класса в интерфейс, совместимый с вашим кодом. Адаптер
позволяет классам работать вместе стандартным образом, что обычно не получается из-за несовместимых интерфейсов,
предоставляя для этого прослойку с интерфейсом, удобным для клиентов, самостоятельно используя оригинальный интерфейс.

## Мост (Bridge)

Шаблон моста предполагает предпочтение композиции наследованию. Детали реализации передаются из иерархии в другой объект
с отдельной иерархией.

Отделить абстракцию от её реализации так, что они могут изменяться независимо друг от друга.

## Преобразователь Данных (Data Mapper)

Преобразователь Данных — это паттерн, который выступает в роли посредника для двунаправленной передачи данных между
постоянным хранилищем данных (часто, реляционной базы данных) и представления данных в памяти (слой домена, то что уже
загружено и используется для логической обработки). Цель паттерна в том, чтобы держать представление данных в памяти и
постоянное хранилище данных независимыми друг от друга и от самого преобразователя данных

Ключевым моментом этого паттерна, в отличие от Активной Записи (Active Records) является то, что модель данных следует
Принципу Единой Обязанности SOLID.

## Декоратор (Decorator)

Шаблон декоратора позволяет динамически изменять поведение объекта во время выполнения, заключая его в объект класса
декоратора.

## Фасад (Facade)

Фасад предназначен для разделения клиента и подсистемы путем внедрения многих (но иногда только одного) интерфейсов, и,
конечно, уменьшения общей сложности.

Вот почему хороший фасад не содержит созданий экземпляров классов (new) внутри. Если внутри фасада создаются объекты для
реализации каждого метода, это не Фасад, это Строитель или [Абстрактная|Статическая|Простая]
Фабрика [или Фабричный Метод].

## Приспособленец (Flyweight)

Для уменьшения использования памяти Приспособленец разделяет как можно больше памяти между аналогичными объектами. Это
необходимо, когда используется большое количество объектов, состояние которых не сильно отличается. Обычной практикой
является хранение состояния во внешних структурах и передавать их в объект-приспособленец, когда необходимо.

## Прокси (Proxy)

Создать интерфейс взаимодействия с любым классом, который трудно или невозможно использовать в оригинальном виде. Класс
представляет функциональность другого класса.

## Шаблоны поведенческого проектирования

## Состояние (State)

Инкапсулирует изменение поведения одних и тех же методов в зависимости от состояния объекта. Этот паттерн поможет
изящным способом изменить поведение объекта во время выполнения не прибегая к большим монолитным условным операторам

## Стратегия (Strategy)

Чтобы разделить стратегии и получить возможность быстрого переключения между ними. Также этот паттерн является хорошей
альтернативой наследованию (вместо расширения абстрактного класса).

## Объект Null (Null Object)

Методы, которые возвращают объект или Null, вместо этого должны вернуть объект NullObject. Это упрощённый формальный
код, устраняющий необходимость проверки if (!is_null($obj)) { $obj->callSomething(); }, заменяя её на обычный вызов
$obj->callSomething();.

## Команда (Command)

Позволяет инкапсулировать действия в объекты. Основная идея этого шаблона — предоставить средства для отделения клиента
от получателя.

## Итератор (Iterator)

Добавить коллекции объектов функционал последовательного доступа к содержащимся в ней экземплярам объектов без
реализации этого функционала в самой коллекции.

## Спецификация (Specification)

Строит ясное описание бизнес-правил, на соответствие которым могут быть проверены объекты. Композитный класс
спецификация имеет один метод, называемый isSatisfiedBy, который возвращает истину или ложь в зависимости от того,
удовлетворяет ли данный объект спецификации.

## Цепочка Обязанностей (Chain Of Responsibilities)

Построить цепочку объектов для обработки вызова в последовательном порядке. Если один объект не может справиться с
вызовом, он делегирует вызов следующему в цепи и так далее.

## Итератор (Iterator)

Добавить коллекции объектов функционал последовательного доступа к содержащимся в ней экземплярам объектов без
реализации этого функционала в самой коллекции.

## Посредник (Mediator)

Этот паттерн позволяет снизить связность множества компонентов, работающих совместно. Объектам больше нет нужды вызывать
друг друга напрямую. Это хорошая альтернатива Наблюдателю, если у вас есть “центр интеллекта” вроде контроллера (но не в
смысле MVC)

Все компоненты (называемые «Коллеги») объединяются в интерфейс Mediator и это хорошо, потому что в рамках ООП, «старый
друг лучше новых двух».

## Хранитель (Memento)

Шаблон предоставляет возможность восстановить объект в его предыдущем состоянии (отменить действие посредством отката к
предыдущему состоянию) или получить доступ к состоянию объекта, не раскрывая его реализацию (т.е. сам объект не обязан
иметь функциональность для возврата текущего состояния).

Шаблон Хранитель реализуется тремя объектами: «Создателем» (originator), «Опекуном» (caretaker) и «Хранитель» (memento).

Хранитель - это объект, который хранит конкретный снимок состояния некоторого объекта или ресурса: строки, числа,
массива, экземпляра класса и так далее. Уникальность в данном случае подразумевает не запрет на существование одинаковых
состояний в разных снимках, а то, что состояние можно извлечь в виде независимой копии. Любой объект, сохраняемый в
Хранителе, должен быть полной копией исходного объекта, а не ссылкой на исходный объект. Сам объект Хранитель является
«непрозрачным объектом» (тот, который никто не может и не должен изменять).

Создатель — это объект, который содержит в себе актуальное состояние внешнего объекта строго заданного типа и умеет
создавать уникальную копию этого состояния, возвращая её, обёрнутую в объект Хранителя. Создатель не знает истории
изменений. Создателю можно принудительно установить конкретное состояние извне, которое будет считаться актуальным.
Создатель должен позаботиться о том, чтобы это состояние соответствовало типу объекта, с которым ему разрешено работать.
Создатель может (но не обязан) иметь любые методы, но они не могут менять сохранённое состояние объекта.

Опекун управляет историей снимков состояний. Он может вносить изменения в объект, принимать решение о сохранении
состояния внешнего объекта в Создателе, запрашивать от Создателя снимок текущего состояния, или привести состояние
Создателя в соответствие с состоянием какого-то снимка из истории.

## Наблюдатель (Observer)

Для реализации публикации/подписки на поведение объекта, всякий раз, когда объект «Subject» меняет свое состояние,
прикрепленные объекты «Observers» будут уведомлены. Паттерн используется, чтобы сократить количество связанных напрямую
объектов и вместо этого использует слабую связь (loose coupling).

## Шаблонный Метод (Template Method)

Возможно, вы сталкивались с этим уже много раз. Идея состоит в том, чтобы позволить наследникам абстрактного шаблона
переопределить поведение алгоритмов родителя.

Как в «Голливудском принципе»: «Не звоните нам, мы сами вам позвоним». Этот класс не вызывается подклассами, но
наоборот: подклассы вызываются родителем. Как? С помощью метода в родительской абстракции, конечно.

Другими словами, это каркас алгоритма, который хорошо подходит для библиотек (в фреймворках, например). Пользователь
просто реализует уточняющие методы, а суперкласс делает всю основную работу.

Это простой способ изолировать логику в конкретные классы и уменьшить копипаст, поэтому вы повсеместно встретите его в
том или ином виде.

## Посетитель (Visitor)

Шаблон «Посетитель» выполняет операции над объектами других классов. Главной целью является сохранение разделения
направленности задач отдельных классов. При этом классы обязаны определить специальный контракт, чтобы позволить
использовать их Посетителям (метод «принять роль» Role::accept в примере).

Контракт, как правило, это абстрактный класс, но вы можете использовать чистый интерфейс. В этом случае, каждый
посетитель должен сам выбирать, какой метод ссылается на посетителя.










































